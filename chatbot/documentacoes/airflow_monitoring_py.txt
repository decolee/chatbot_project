Importa√ß√µes e Configura√ß√µes Iniciais
import streamlit as st
import requests
from requests.auth import HTTPBasicAuth
import pandas as pd
import plotly.express as px
import plotly.graph_objects as go
from datetime import datetime, timedelta
import networkx as nx

# Configura√ß√µes
AIRFLOW_URL = "http://localhost:8080/api/v1"
AIRFLOW_USER = "admin"
AIRFLOW_PASSWORD = "admin"
Esta se√ß√£o importa as bibliotecas necess√°rias e define as configura√ß√µes iniciais para a conex√£o com a API do Airflow. As principais bibliotecas utilizadas s√£o:

Streamlit: para criar a interface web interativa
Requests: para fazer chamadas √† API do Airflow
Pandas: para manipula√ß√£o de dados
Plotly: para criar visualiza√ß√µes interativas
NetworkX: para an√°lise de grafos (usado na an√°lise de depend√™ncias)
As configura√ß√µes do Airflow (URL, usu√°rio e senha) s√£o definidas como constantes.

Fun√ß√µes Auxiliares
def airflow_api_request(endpoint):
    try:
        response = requests.get(
            f"{AIRFLOW_URL}/{endpoint}",
            auth=HTTPBasicAuth(AIRFLOW_USER, AIRFLOW_PASSWORD)
        )
        response.raise_for_status()
        return response.json()
    except requests.RequestException as e:
        st.error(f"Erro ao acessar a API do Airflow: {e}")
        return None

@st.cache_data(ttl=300)
def get_dags_data():
    dags = airflow_api_request("dags")
    if dags:
        return pd.DataFrame(dags['dags'])
    return pd.DataFrame()

@st.cache_data(ttl=60)
def get_recent_dag_runs():
    dag_runs = airflow_api_request("dags/~/dagRuns")
    if dag_runs:
        return pd.DataFrame(dag_runs['dag_runs'])
    return pd.DataFrame()
Estas fun√ß√µes auxiliares s√£o respons√°veis por:

airflow_api_request: Faz requisi√ß√µes √† API do Airflow, lidando com autentica√ß√£o e erros.
get_dags_data: Obt√©m dados de todas as DAGs e os converte para um DataFrame do Pandas. Usa cache do Streamlit com TTL de 300 segundos.
get_recent_dag_runs: Obt√©m dados das execu√ß√µes recentes de DAGs. Usa cache com TTL de 60 segundos.
Configura√ß√£o da P√°gina e Navega√ß√£o
st.set_page_config(page_title="Airflow Analytics Dashboard", layout="wide")

st.sidebar.title("Navega√ß√£o")
page = st.sidebar.radio("Escolha uma p√°gina", ["Vis√£o Geral", "Detalhes das DAGs", "M√©tricas de Desempenho", "An√°lise de Depend√™ncias"])
Esta se√ß√£o configura o layout da p√°gina e cria um menu de navega√ß√£o na barra lateral, permitindo ao usu√°rio escolher entre diferentes p√°ginas do dashboard.

P√°gina de Vis√£o Geral
if page == "Vis√£o Geral":
    st.title("Airflow Analytics Dashboard")
    
    col1, col2 = st.columns(2)
    
    with col1:
        st.metric("Total de DAGs", len(get_dags_data()))
        
    with col2:
        recent_runs = get_recent_dag_runs()
        st.metric("Execu√ß√µes nas √∫ltimas 24h", len(recent_runs[recent_runs['execution_date'] > (datetime.now() - timedelta(days=1)).isoformat()]))
    
    # Gr√°fico de status das DAGs
    dags_df = get_dags_data()
    status_counts = dags_df['is_paused'].value_counts()
    fig = px.pie(values=status_counts.values, names=status_counts.index, title="Status das DAGs")
    st.plotly_chart(fig)
    
    # Tabela de DAGs com indicador visual
    st.subheader("Lista de DAGs")
    
    def status_indicator(is_paused):
        return "üü¢" if not is_paused else "‚ö™"
    
    dags_df['Status'] = dags_df['is_paused'].apply(status_indicator)
    dags_df = dags_df[['Status', 'dag_id', 'last_parsed_time']]
    st.dataframe(dags_df, hide_index=True)
    
    placeholder = st.empty()
    placeholder.markdown("üü¢ DAGs Online")
Esta p√°gina fornece uma vis√£o geral do Airflow, incluindo:

M√©tricas de total de DAGs e execu√ß√µes recentes
Um gr√°fico de pizza mostrando o status das DAGs (pausadas ou ativas)
Uma tabela com lista de DAGs, incluindo um indicador visual de status
P√°gina de Detalhes das DAGs
elif page == "Detalhes das DAGs":
    st.title("Detalhes das DAGs")
    
    selected_dag = st.selectbox("Escolha uma DAG", get_dags_data()['dag_id'])
    
    if selected_dag:
        dag_details = airflow_api_request(f"dags/{selected_dag}")
        if dag_details:
            st.json(dag_details)
        
        st.subheader("Execu√ß√µes Recentes")
        dag_runs = airflow_api_request(f"dags/{selected_dag}/dagRuns")
        if dag_runs:
            st.dataframe(pd.DataFrame(dag_runs['dag_runs']))
Esta p√°gina permite ao usu√°rio selecionar uma DAG espec√≠fica e ver seus detalhes, incluindo:

Informa√ß√µes detalhadas da DAG selecionada
Uma tabela com as execu√ß√µes recentes da DAG selecionada
P√°gina de M√©tricas de Desempenho
elif page == "M√©tricas de Desempenho":
    st.title("M√©tricas de Desempenho")
    
    performance_data = {
        'DAG': ['execute_jupyter_notebooks', 'kafka_analytics', 'mongodb_simple_check', 
                'monitor_elasticsearch', 'monitor_postgres', 'spark_output_analytics'],
        'Tempo M√©dio de Execu√ß√£o (min)': [20, 15, 5, 3, 2, 22],
        'Taxa de Sucesso (%)': [98, 97, 99, 99.5, 99.8, 95],
        'Uso de CPU (%)': [30, 25, 10, 5, 5, 40],
        'Uso de Mem√≥ria (MB)': [512, 256, 128, 64, 64, 1024]
    }
    perf_df = pd.DataFrame(performance_data)
    
    # Gr√°fico de barras para m√©tricas de desempenho
    fig = go.Figure()
    fig.add_trace(go.Bar(name='Tempo M√©dio de Execu√ß√£o', x=perf_df['DAG'], y=perf_df['Tempo M√©dio de Execu√ß√£o (min)']))
    fig.add_trace(go.Bar(name='Taxa de Sucesso', x=perf_df['DAG'], y=perf_df['Taxa de Sucesso (%)']))
    fig.update_layout(barmode='group', title="M√©tricas de Desempenho por DAG")
    st.plotly_chart(fig)
    
    # Gr√°fico de radar para uso de recursos
    fig_radar =```
Private 
Suggestions
continue
 # Gr√°fico de radar para uso de recursos
Answer | Claude 3.5 Sonnet Model
Continuando a explica√ß√£o detalhada do c√≥digo:

P√°gina de M√©tricas de Desempenho (continua√ß√£o)
# Gr√°fico de radar para uso de recursos
fig_radar = go.Figure()
for dag in perf_df['DAG']:
    fig_radar.add_trace(go.Scatterpolar(
        r=[perf_df[perf_df['DAG'] == dag]['Uso de CPU (%)'].values[0],
           perf_df[perf_df['DAG'] == dag]['Uso de Mem√≥ria (MB)'].values[0],
           perf_df[perf_df['DAG'] == dag]['Tempo M√©dio de Execu√ß√£o (min)'].values[0]],
        theta=['CPU', 'Mem√≥ria', 'Tempo de Execu√ß√£o'],
        fill='toself',
        name=dag
    ))
fig_radar.update_layout(
    polar=dict(radialaxis=dict(visible=True, range=[0, 100])),
    showlegend=True,
    title="Uso de Recursos por DAG"
)
st.plotly_chart(fig_radar)

st.dataframe(perf_df)
Esta se√ß√£o cria um gr√°fico de radar para visualizar o uso de recursos por DAG. O gr√°fico mostra tr√™s m√©tricas para cada DAG: uso de CPU, uso de mem√≥ria e tempo m√©dio de execu√ß√£o. Cada DAG √© representada por uma √°rea no gr√°fico radar, permitindo uma compara√ß√£o visual r√°pida do uso de recursos entre as DAGs.

Ap√≥s o gr√°fico de radar, o c√≥digo exibe uma tabela com todos os dados de desempenho usando st.dataframe(perf_df).

P√°gina de An√°lise de Depend√™ncias
elif page == "An√°lise de Depend√™ncias":
    st.title("An√°lise de Depend√™ncias de DAGs")
    
    # Simulando dados de depend√™ncias (substitua por dados reais se dispon√≠veis)
    dependencies = {
        'execute_jupyter_notebooks': ['kafka_analytics', 'spark_output_analytics'],
        'kafka_analytics': ['mongodb_simple_check'],
        'mongodb_simple_check': ['monitor_elasticsearch'],
        'monitor_elasticsearch': ['monitor_postgres'],
        'monitor_postgres': [],
        'spark_output_analytics': ['monitor_elasticsearch']
    }
    
    # Criando um grafo de depend√™ncias
    G = nx.DiGraph(dependencies)
    
    # Visualiza√ß√£o do grafo
    pos = nx.spring_layout(G)
    edge_x = []
    edge_y = []
    for edge in G.edges():
        x0, y0 = pos[edge[0]]
        x1, y1 = pos[edge[1]]
        edge_x.extend([x0, x1, None])
        edge_y.extend([y0, y1, None])

    edge_trace = go.Scatter(
        x=edge_x, y=edge_y,
        line=dict(width=0.5, color='#888'),
        hoverinfo='none',
        mode='lines')

    node_x = []
    node_y = []
    for node in G.nodes():
        x, y = pos[node]
        node_x.append(x)
        node_y.append(y)

    node_trace = go.Scatter(
        x=node_x, y=node_y,
        mode='markers',
        hoverinfo='text',
        marker=dict(
            showscale=True,
            colorscale='YlGnBu',
            reversescale=True,
            color=[],
            size=10,
            colorbar=dict(
                thickness=15,
                title='Grau do N√≥',
                xanchor='left',
                titleside='right'
            ),
            line_width=2))

    # Cor dos n√≥s baseada no grau
    node_adjacencies = []
    node_text = []
    for node, adjacencies in enumerate(G.adjacency()):
        node_adjacencies.append(len(adjacencies[1]))
        node_text.append(f'{adjacencies[0]}<br># de conex√µes: {len(adjacencies[1])}')

    node_trace.marker.color = node_adjacencies
    node_trace.text = node_text

    # Criando a figura
    fig = go.Figure(data=[edge_trace, node_trace],
                    layout=go.Layout(
                        title='Grafo de Depend√™ncias das DAGs',
                        titlefont_size=16,
                        showlegend=False,
                        hovermode='closest',
                        margin=dict(b=20,l=5,r=5,t=40),
                        annotations=[ dict(
                            text="",
                            showarrow=False,
                            xref="paper", yref="paper",
                            x=0.005, y=-0.002 ) ],
                        xaxis=dict(showgrid=False, zeroline=False, showticklabels=False),
                        yaxis=dict(showgrid=False, zeroline=False, showticklabels=False))
                    )

    st.plotly_chart(fig)
Esta se√ß√£o cria uma visualiza√ß√£o interativa do grafo de depend√™ncias das DAGs:

Simula dados de depend√™ncias entre DAGs (em um cen√°rio real, esses dados seriam obtidos do Airflow).
Cria um grafo direcionado usando NetworkX.
Gera uma visualiza√ß√£o interativa do grafo usando Plotly, onde:
Os n√≥s representam as DAGs
As arestas representam as depend√™ncias entre DAGs
A cor e o tamanho dos n√≥s s√£o baseados no n√∫mero de conex√µes (grau do n√≥)
An√°lise de Depend√™ncias Cr√≠ticas
# An√°lise de depend√™ncias cr√≠ticas
st.subheader("An√°lise de Depend√™ncias Cr√≠ticas")
critical_paths = list(nx.all_simple_paths(G, 'execute_jupyter_notebooks', 'monitor_postgres'))

if critical_paths:
    st.write("Caminhos cr√≠ticos identificados:")
    for i, path in enumerate(critical_paths, 1):
        st.write(f"{i}. {' -> '.join(path)}")
    
    longest_path = max(critical_paths, key=len)
    st.write(f"Caminho mais longo: {' -> '.join(longest_path)}")
    st.write(f"N√∫mero de etapas no caminho mais longo: {len(longest_path)}")
else:
    st.write("Nenhum caminho cr√≠tico identificado.")

# Sugest√µes de otimiza√ß√£o
st.subheader("Sugest√µes de Otimiza√ß√£o")
high_degree_nodes = sorted(G.degree, key=lambda x: x[1], reverse=True)[:3]
st.write("DAGs com mais depend√™ncias (potenciais gargalos):")
for node, degree in high_degree_nodes:
    st.write(f"- {node}: {degree} conex√µes")

st.write("Sugest√µes de otimiza√ß√£o:")
st.write("1. Considere paralelizar tarefas em DAGs com alto grau de depend√™ncia.")
st.write("2. Revise a necessidade de todas as depend√™ncias nos caminhos cr√≠ticos.")
st.write("3. Monitore de perto o desempenho das DAGs no caminho mais longo.")
Esta se√ß√£o realiza uma an√°lise mais profunda das depend√™ncias:

Identifica caminhos cr√≠ticos no grafo de depend√™ncias.
Mostra o caminho mais longo e seu n√∫mero de etapas.
Identifica DAGs com mais depend√™ncias (potenciais gargalos).
Fornece sugest√µes de otimiza√ß√£o baseadas na an√°lise.